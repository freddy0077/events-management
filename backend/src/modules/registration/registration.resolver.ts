import { Resolver, Query, Mutation, Args, ID, Context, ResolveField, Parent, Int } from '@nestjs/graphql';
import { UseGuards } from '@nestjs/common';
import { RegistrationService } from './registration.service';
import { QRCodeService } from '../../services/qr-code.service';
import { BadgeService } from '../../services/badge.service';
import { TransactionService } from '../transaction/transaction.service';
import { Registration } from './entities/registration.entity';
import { Event } from '../events/entities/event.entity';
import { Category } from '../events/entities/category.entity';
import { MealAttendance } from '../meals/entities/meal-attendance.entity';
import { Transaction } from '../transaction/transaction.types';
import { 
  CreateRegistrationInput, 
  CreateStaffRegistrationInput,
  UpdateRegistrationInput, 
  RegistrationPayload, 
  PaymentConfirmationPayload,
  QRCodeGenerationResult,
  QRCodeValidationResult 
} from './dto/registration.dto';
import { GqlAuthGuard } from '../auth/guards/gql-auth.guard';
import { StaffPermissionGuard, StaffPermissions, StaffPermission } from '../auth/guards/staff-permission.guard';
import { PaymentMethod } from '@prisma/client';
import { Audit } from '../../decorators/audit.decorator';

@Resolver(() => Registration)
export class RegistrationResolver {
  constructor(
    private registrationService: RegistrationService,
    private qrCodeService: QRCodeService,
    private badgeService: BadgeService,
    private transactionService: TransactionService,
  ) {}

  @Mutation(() => RegistrationPayload)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.CREATE_REGISTRATION)
  @Audit({ 
    action: 'REGISTRATION_CREATED', 
    resourceType: 'registration',
    description: 'User created a new participant registration',
    includeRequest: true 
  })
  async createRegistration(
    @Args('input') createRegistrationInput: CreateRegistrationInput,
    @Context() context: any,
  ): Promise<RegistrationPayload> {
    const userId = context.req.user.id;
    const registration = await this.registrationService.createRegistration(userId, createRegistrationInput);
    
    // Get category price for payment URL
    const category = await this.registrationService.getCategoryById(registration.categoryId);
    
    return {
      registration,
      qrCodeData: '', // QR code will be generated by centralized service when payment is confirmed
      paymentUrl: category.price.toNumber() > 0 ? '/payment/' + registration.id : null,
    };
  }

  @Mutation(() => RegistrationPayload)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.CREATE_REGISTRATION)
  async createStaffRegistration(
    @Args('input') createStaffRegistrationInput: CreateStaffRegistrationInput,
    @Context() context: any,
  ): Promise<RegistrationPayload> {
    console.log('=== CreateStaffRegistration Resolver Debug ===');
    console.log('Input received:', JSON.stringify(createStaffRegistrationInput, null, 2));
    console.log('User context:', context.req.user ? `ID: ${context.req.user.id}, Email: ${context.req.user.email}` : 'No user');
    
    try {
      const staffUserId = context.req.user.id;
      console.log('Calling service with staffUserId:', staffUserId);
      
      const registration = await this.registrationService.createStaffRegistration(staffUserId, createStaffRegistrationInput);
      
      console.log('Service returned result:', registration ? 'Success' : 'Failed');
      
      // Get category price for payment URL - only needed if payment is not yet processed
      const category = await this.registrationService.getCategoryById(registration.categoryId);
      const needsPayment = !createStaffRegistrationInput.paymentMethod && category.price.toNumber() > 0;
      
      console.log('Payment needed:', needsPayment);
      
      // Generate QR code only if payment is provided (staff registration with payment)
      let qrCodeData = '';
      if (createStaffRegistrationInput.paymentMethod) {
        try {
          const qrResult = await this.qrCodeService.generateQRCode(registration.id);
          qrCodeData = qrResult.base64Image;
        } catch (error) {
          console.error('Failed to generate QR code for staff registration:', error.message);
          // Continue without QR code - it can be generated later when payment is confirmed
        }
      }
      
      return {
        registration,
        qrCodeData,
        paymentUrl: needsPayment ? '/payment/' + registration.id : null,
      };
    } catch (error) {
      // Log the actual error for debugging
      console.error('=== CreateStaffRegistration Resolver Error ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      
      // Re-throw the original error to preserve the specific error type and message
      throw error;
    }
  }

  @Query(() => [Registration])
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  // @StaffPermissions(StaffPermission.VIEW_REPORTS)
  async registrations(
    @Args('eventId', { type: () => String, nullable: true }) eventId?: string,
    @Args('eventIds', { type: () => [String], nullable: true }) eventIds?: string[],
    @Args('limit', { type: () => Int, nullable: true }) limit?: number,
    @Args('offset', { type: () => Int, nullable: true }) offset?: number,
  ): Promise<Registration[]> {
    return this.registrationService.findRegistrations(eventId, eventIds, limit, offset);
  }

  @Query(() => [Registration])
  @UseGuards(GqlAuthGuard)
  async myRegistrations(@Context() context: any): Promise<Registration[]> {
    const userId = context.req.user.id;
    return this.registrationService.findRegistrationsByUser(userId);
  }

  @Query(() => [Registration])
  @UseGuards(GqlAuthGuard)
  async eventRegistrations(
    @Args('eventId', { type: () => ID }) eventId: string,
  ): Promise<Registration[]> {
    return this.registrationService.findRegistrationsByEvent(eventId);
  }

  @Query(() => Registration)
  @UseGuards(GqlAuthGuard)
  async registration(
    @Args('id', { type: () => ID }) id: string,
  ): Promise<Registration> {
    return this.registrationService.findRegistrationById(id);
  }

  @Query(() => Registration)
  @UseGuards(GqlAuthGuard)
  async registrationByQRCode(
    @Args('qrCode') qrCode: string,
  ): Promise<Registration> {
    return this.registrationService.findRegistrationByQRCode(qrCode);
  }

  @Query(() => Registration, { nullable: true })
  async searchRegistrationByReceipt(
    @Args('receiptNumber') receiptNumber: string,
  ): Promise<Registration | null> {
    return this.registrationService.searchRegistrationByReceipt(receiptNumber);
  }

  @Mutation(() => Registration)
  @UseGuards(GqlAuthGuard)
  async updateRegistration(
    @Args('id', { type: () => ID }) id: string,
    @Args('input') updateRegistrationInput: UpdateRegistrationInput,
  ): Promise<Registration> {
    return this.registrationService.updateRegistration(id, updateRegistrationInput);
  }

  @Mutation(() => PaymentConfirmationPayload)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.PROCESS_PAYMENT)
  async processPayment(
    @Args('registrationId', { type: () => ID }) registrationId: string,
    @Args('amount') amount: number,
    @Args('paymentMethod', { type: () => PaymentMethod }) paymentMethod: PaymentMethod,
    @Args('paymentReference', { nullable: true }) paymentReference?: string,
    @Args('notes', { nullable: true }) notes?: string,
    @Context() context?: any,
  ): Promise<PaymentConfirmationPayload> {
    try {
      const userId = context.req.user.id;
      
      // Create transaction record
      const transaction = await this.transactionService.createTransaction(userId, {
        registrationId,
        amount,
        paymentMethod,
        receiptNumber: paymentReference,
        notes,
      });

      // Get updated registration
      const registration = await this.registrationService.findRegistrationById(registrationId);
      
      return {
        success: true,
        registration,
        message: 'Payment processed successfully',
      };
    } catch (error) {
      return {
        success: false,
        registration: null,
        message: error.message,
      };
    }
  }

  @Mutation(() => PaymentConfirmationPayload)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.APPROVE_PAYMENT)
  async confirmPayment(
    @Args('transactionId', { type: () => ID }) transactionId: string,
    @Args('paymentDate', { nullable: true }) paymentDate?: Date,
    @Context() context?: any,
  ): Promise<PaymentConfirmationPayload> {
    try {
      const userId = context.req.user.id;
      
      // Confirm the transaction
      const transaction = await this.transactionService.confirmPayment(transactionId, userId, paymentDate);
      
      // Get updated registration
      const registration = await this.registrationService.findRegistrationById(transaction.registrationId);
      
      return {
        success: true,
        registration,
        message: 'Payment confirmed successfully',
      };
    } catch (error) {
      return {
        success: false,
        registration: null,
        message: error.message,
      };
    }
  }

  @Mutation(() => Boolean)
  @UseGuards(GqlAuthGuard)
  async cancelRegistration(
    @Args('id', { type: () => ID }) id: string,
  ): Promise<boolean> {
    return this.registrationService.cancelRegistration(id);
  }

  // QR Code Mutations
  @Mutation(() => QRCodeGenerationResult)
  @UseGuards(GqlAuthGuard)
  async generateQRCode(
    @Args('registrationId', { type: () => ID }) registrationId: string,
  ): Promise<QRCodeGenerationResult> {
    return this.qrCodeService.generateQRCode(registrationId);
  }

  @Mutation(() => QRCodeGenerationResult)
  @UseGuards(GqlAuthGuard)
  async regenerateQRCode(
    @Args('registrationId', { type: () => ID }) registrationId: string,
  ): Promise<QRCodeGenerationResult> {
    return this.qrCodeService.regenerateQRCode(registrationId);
  }

  @Query(() => QRCodeValidationResult)
  @UseGuards(GqlAuthGuard)
  async validateQRCode(
    @Args('qrCode') qrCode: string,
  ): Promise<QRCodeValidationResult> {
    try {
      const payload = await this.qrCodeService.validateQRCode(qrCode);
      return {
        isValid: payload !== null,
        payload,
        message: payload ? 'QR code is valid' : 'QR code is invalid or expired',
      };
    } catch (error) {
      return {
        isValid: false,
        payload: null,
        message: error.message,
      };
    }
  }

  @Query(() => String, { nullable: true })
  @UseGuards(GqlAuthGuard)
  async getQRCodeImage(
    @Args('registrationId', { type: () => ID }) registrationId: string,
  ): Promise<string | null> {
    return this.qrCodeService.getQRCodeImage(registrationId);
  }

  @Mutation(() => [QRCodeGenerationResult])
  @UseGuards(GqlAuthGuard)
  async bulkGenerateQRCodes(
    @Args('registrationIds', { type: () => [ID] }) registrationIds: string[],
  ): Promise<QRCodeGenerationResult[]> {
    return this.qrCodeService.bulkGenerateQRCodes(registrationIds);
  }

  // Badge Generation Mutations
  @Mutation(() => String)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.MANAGE_BADGES)
  async generateBadge(
    @Args('registrationId', { type: () => ID }) registrationId: string,
    @Args('format', { type: () => String, defaultValue: 'pdf' }) format: string,
    @Args('badgeTemplateId', { type: () => String, nullable: true }) badgeTemplateId?: string,
  ): Promise<string> {
    console.log('=== GraphQL Resolver Debug ===');
    console.log('Registration ID:', registrationId);
    console.log('Format:', format);
    console.log('Badge Template ID:', badgeTemplateId);
    
    const result = await this.badgeService.generateBadge(registrationId, { 
      format: format as any, 
      badgeTemplateId 
    });
    // Return base64 encoded badge data
    return result.printData.toString('base64');
  }

  @Mutation(() => String)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.MANAGE_BADGES)
  async generateBadgeSheet(
    @Args('registrationIds', { type: () => [ID] }) registrationIds: string[],
  ): Promise<string> {
    const result = await this.badgeService.generateBadgeSheet(registrationIds);
    // Return base64 encoded PDF data
    return result.toString('base64');
  }

  @Mutation(() => String)
  @UseGuards(GqlAuthGuard, StaffPermissionGuard)
  @StaffPermissions(StaffPermission.MANAGE_BADGES)
  async regenerateBadge(
    @Args('registrationId', { type: () => ID }) registrationId: string,
    @Args('format', { type: () => String, defaultValue: 'pdf' }) format: string,
    @Args('badgeTemplateId', { type: () => String, nullable: true }) badgeTemplateId?: string,
  ): Promise<string> {
    const result = await this.badgeService.regenerateBadge(registrationId, { 
      format: format as any, 
      badgeTemplateId 
    });
    // Return base64 encoded badge data
    return result.printData.toString('base64');
  }

  // Field resolvers for computed fields
  @ResolveField(() => String)
  firstName(@Parent() registration: Registration): string {
    const nameParts = registration.fullName.split(' ');
    return nameParts[0] || '';
  }

  @ResolveField(() => String)
  lastName(@Parent() registration: Registration): string {
    const nameParts = registration.fullName.split(' ');
    return nameParts.slice(1).join(' ') || '';
  }

  // Field resolvers for relations
  @ResolveField(() => Event)
  async event(@Parent() registration: Registration): Promise<Event> {
    return this.registrationService.getEventByRegistration(registration.id);
  }

  @ResolveField(() => Category)
  async category(@Parent() registration: Registration): Promise<Category> {
    return this.registrationService.getCategoryById(registration.categoryId);
  }

  @ResolveField(() => [MealAttendance])
  async mealAttendances(@Parent() registration: Registration): Promise<MealAttendance[]> {
    return this.registrationService.getMealAttendancesByRegistration(registration.id);
  }

  @ResolveField(() => [Transaction])
  async transactions(@Parent() registration: Registration): Promise<Transaction[]> {
    return this.transactionService.getTransactionsByRegistration(registration.id);
  }

  @ResolveField(() => String)
  async paymentStatus(@Parent() registration: Registration): Promise<string> {
    // Get transactions for this registration
    const transactions = await this.transactionService.getTransactionsByRegistration(registration.id);
    
    // Check if there's a paid transaction
    const paidTransaction = transactions.find(t => t.paymentStatus === 'PAID');
    if (paidTransaction) {
      return 'PAID';
    }
    
    // Check if there are any pending transactions
    const pendingTransaction = transactions.find(t => t.paymentStatus === 'PENDING');
    if (pendingTransaction) {
      return 'PENDING';
    }
    
    // Default to pending if no transactions exist
    return 'PENDING';
  }
}
